{"version":3,"sources":["object.ts"],"names":["stringify","require","arraySort","ArrayUtils","contains","str","searchIn","retVal","i","length","includes","exactMatch","startsWith","endsWith","inExcludeList","list","search","undefined","inList","Array","cfg","AppConfig","getInstance","options","excludeList","ObjectUtils","mergeDeep","target","src","Object","keys","forEach","key","value","type","isArray","toString","obj","color","maxNrOfItems","maxItems","JSON","Dataset","sort","data","fields","extractFields","log","Logger","rec","record","fld","info","push"],"mappings":"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","sourcesContent":["import { Logger } from \"./log\";\nimport { AppConfig } from \"./config\";\nconst { stringify } = require(\"q-i\");\nconst arraySort = require(\"array-sort\");\n\nexport class ArrayUtils {\n\tstatic contains(str: string, searchIn: string[]): boolean {\n\t\tlet retVal = false;\n\t\tfor (let i = 0; i < searchIn.length; i++) {\n\t\t\tif (str.includes(searchIn[i])) {\n\t\t\t\tretVal = true;\n\t\t\t}\n\t\t}\n\t\treturn retVal;\n\t}\n\n\tstatic exactMatch(str: string, searchIn: string[]): boolean {\n\t\treturn searchIn.includes(str);\n\t}\n\n\tstatic startsWith(str: string, searchIn: string[]): boolean {\n\t\tlet retVal = false;\n\t\tfor (let i = 0; i < searchIn.length; i++) {\n\t\t\tif (str.startsWith(searchIn[i])) {\n\t\t\t\tretVal = true;\n\t\t\t}\n\t\t}\n\t\treturn retVal;\n\t}\n\n\tstatic endsWith(str: string, searchIn: string[]): boolean {\n\t\tlet retVal = false;\n\t\tfor (let i = 0; i < searchIn.length; i++) {\n\t\t\tif (str.endsWith(searchIn[i])) {\n\t\t\t\tretVal = true;\n\t\t\t}\n\t\t}\n\t\treturn retVal;\n\t}\n\n\t/**\n\t * <p>\n\t *   Method to determine if a search string is in an exclude list. Two procedures possible:\n\t * </p>\n\t *\n\t * @example Simple exclude list\n\t *\n\t * let exclude = ArrayUtils.inExcludeList([\n\t *   \"abc\",\n\t *   \"def\",\n\t *   \"ghi\"\n\t * ], \"abc\");\n\t *\n\t * @example Detailed exclude list. All keys are optional\n\t *\n\t * let exclude = ArrayUtils.inExcludeList({\n\t *     contains: [\n\t *       \"abc\"\n\t *     ],\n\t *     exactMatch: [\n\t *       \"def\"\n\t *     ],\n\t *     startsWith: [\n\t *       \"ghi\"\n\t *     ],\n\t *     endsWith: [\n\t *       \"jkl\"\n\t *     ]\n\t *   }, \"abc\");\n\t *\n\t */\n\tstatic inExcludeList(list: any, search: string): boolean {\n\t\tif (list == undefined || list.length == 0) return false;\n\n\t\tlet inList = false;\n\n\t\tif (list instanceof Array) {\n\t\t\t// Use default config for exclude list\n\t\t\tlet cfg = AppConfig.getInstance();\n\t\t\tif (cfg.options.excludeList.contains) {\n\t\t\t\tinList = ArrayUtils.contains(search, list);\n\t\t\t}\n\t\t\tif (cfg.options.excludeList.exactMatch) {\n\t\t\t\tinList = inList || ArrayUtils.exactMatch(search, list);\n\t\t\t}\n\t\t\tif (cfg.options.excludeList.startsWith) {\n\t\t\t\tinList = inList || ArrayUtils.startsWith(search, list);\n\t\t\t}\n\t\t\tif (cfg.options.excludeList.endsWith) {\n\t\t\t\tinList = inList || ArrayUtils.endsWith(search, list);\n\t\t\t}\n\t\t} else {\n\t\t\t// Use detailed exclude list\n\t\t\tif (list.contains instanceof Array) {\n\t\t\t\tinList = ArrayUtils.contains(search, list.contains);\n\t\t\t}\n\t\t\tif (list.exactMatch instanceof Array) {\n\t\t\t\tinList = inList || ArrayUtils.exactMatch(search, list.exactMatch);\n\t\t\t}\n\t\t\tif (list.startsWith instanceof Array) {\n\t\t\t\tinList = inList || ArrayUtils.startsWith(search, list.startsWith);\n\t\t\t}\n\t\t\tif (list.endsWith instanceof Array) {\n\t\t\t\tinList = inList || ArrayUtils.endsWith(search, list.endsWith);\n\t\t\t}\n\t\t}\n\t\treturn inList;\n\t}\n}\n\nexport class ObjectUtils {\n\t/**\n\t * Merge src object into target, like .json\n\t *\n\t * @param target {Object}\n\t * @param src {Object}\n\t */\n\tstatic mergeDeep(target: any, src: any): void {\n\t\tObject.keys(src).forEach((key: string) => {\n\t\t\tlet value = src[key];\n\t\t\tif (target[key] == undefined) {\n\t\t\t\ttarget[key] = value; // Key doesn't exist yet, add\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlet type = typeof value;\n\n\t\t\tif (type == \"object\" && !Array.isArray(value)) {\n\t\t\t\tObjectUtils.mergeDeep(target[key], value); // Go level deeper\n\t\t\t} else {\n\t\t\t\ttarget[key] = value; // Overwrite\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get object as colored structure, using package q-i\n\t */\n\tstatic toString(\n\t\tobj: Object,\n\t\tcolor: boolean = false,\n\t\tmaxNrOfItems: number = 30\n\t): string {\n\t\tif (color) {\n\t\t\treturn stringify(obj, { maxItems: maxNrOfItems });\n\t\t\t// print(obj); (after import from q-i)\n\t\t} else {\n\t\t\treturn JSON.stringify(obj, null, \"    \");\n\t\t}\n\t}\n}\n\n/**\n * Class to deal with dataasets of records, like resultsets from database or similar entries in a .json file\n */\nexport class Dataset {\n\t/**\n\t * Sort an array with results\n\t *\n\t * @param data\n\t * @param fields\n\t */\n\tstatic sort(data: any[], fields: any[]): any[] {\n\t\treturn arraySort(data, fields);\n\t}\n\n\t/**\n\t * Take data from an array with results and return a resultset with the same entries, though including only specified fields\n\t *\n\t * @param data\n\t * @param fields\n\t */\n\tstatic extractFields(data: any[], fields: any[]): any[] {\n\t\tlet log = Logger.getInstance();\n\t\tlet retVal = [];\n\n\t\tfor (let rec = 0; rec < data.length; rec++) {\n\t\t\tlet record = {};\n\t\t\tfor (let fld = 0; fld < fields.length; fld++) {\n\t\t\t\tconst key = fields[fld];\n\t\t\t\tif (data[rec][key] == undefined) {\n\t\t\t\t\tlog.info(`Key ${key} not found in record ${rec}`);\n\t\t\t\t} else {\n\t\t\t\t\trecord[key] = data[rec][key];\n\t\t\t\t}\n\t\t\t}\n\t\t\tretVal.push(record);\n\t\t}\n\t\treturn retVal;\n\t}\n}\n"]}